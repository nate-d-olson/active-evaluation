

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aegis.acteval.metrics &mdash; aegis v2020.03.03 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> aegis
          

          
          </a>

          
            
            
              <div class="version">
                v2020.03.03
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Aegis Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#quick-start">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#running-experiments-with-aegis-when-ground-truth-is-known">Running Experiments with Aegis when Ground Truth is Known</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#code-approach">Code Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#running-continuous-integration-components-locally">Running Continuous Integration Components Locally</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#license">LICENSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#disclaimer">Disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">CHANGELOG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../API_reference.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">aegis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>aegis.acteval.metrics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aegis.acteval.metrics</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sklearn.metrics</span> <span class="k">as</span> <span class="nn">skm</span>


<div class="viewcode-block" id="Metric"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric">[docs]</a><span class="k">class</span> <span class="nc">Metric</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class representing a metric, which both scores trials as well as esimates the means,</span>
<span class="sd">    variances, and confidence intervals of a set of trials.</span>

<span class="sd">    Metric is an abstract class that must be implemented. Given a stratum, compute the mean,</span>
<span class="sd">    variance, and confidence intervals. Given strata, compute the</span>
<span class="sd">    overall mean, variance,  and confidence intervals. Method implementations common to all</span>
<span class="sd">    metrics are implemented here.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            No arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="Metric.get_metric_name"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.get_metric_name">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_metric_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the metric as a string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the metric name</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.find_needed_initial_samples"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.find_needed_initial_samples">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">find_needed_initial_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">initial_samples_per_bin</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In order to cover the case where we don&#39;t sample from each stratum necessary edge cases</span>
<span class="sd">        (Such as when the metric is a combination of two components) and to ensure samples</span>
<span class="sd">        from each stratum, this method will find such examples and will sample uniformly at random</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object to find</span>
<span class="sd">                needed samples</span>
<span class="sd">            initial_samples_per_bin (int): The number of initial samples per bin</span>
<span class="sd">            rng (:obj:`numpy.random.RandomState`): random state object with stored random state</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial_id values to sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_samples_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_samples_all_systems">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_samples_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to determine how</span>
<span class="sd">                many samples count towards the population</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of samples counted for the systems, in the order of the</span>
<span class="sd">            systems in the stratum object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_pop_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_pop_all_systems">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_pop_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the total number of trials to be considered for the metric computation.</span>

<span class="sd">        Although it seems obvious for metrics like &quot;accuracy&quot; where the population is the</span>
<span class="sd">        number of trials, it can be more complex for other methods. For instance, when computing</span>
<span class="sd">        precision, the population is the number of trials where the output converts to a positive.</span>
<span class="sd">        This means that the population is far less than the number of trials.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to determine the</span>
<span class="sd">                population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population sizes, with the ith element being the population</span>
<span class="sd">            size for system i. Population sizes can differ for systems for metrics like precision,</span>
<span class="sd">            where the population size is the number of system positive trials. Although true</span>
<span class="sd">            populations are always integers, estimates could be either ints or floats.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_pop_frac_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_pop_frac_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_frac_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the fraction of relevant trials for each stratum for each system. Calls</span>
<span class="sd">        estimate_pop_all_systems() method of metric class. Each fraction is a value from 0 to 1.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population percentages, with the ith element being the</span>
<span class="sd">            population percentage estimate for system i. For some metrics this is known; for</span>
<span class="sd">            other metrics this is estimated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop_perc_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span><span class="o">/</span><span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span>
        <span class="k">return</span> <span class="n">pop_perc_list</span></div>

<div class="viewcode-block" id="Metric.get_trials_to_sample_from"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.get_trials_to_sample_from">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_trials_to_sample_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a stratum, determine the subset of trials that the stratum should draw from.</span>
<span class="sd">        If all samples are relevant, return all of the trial ids. This is useful for metrics like</span>
<span class="sd">        precision where we must subset the number of trials so that we only sample from trials</span>
<span class="sd">        where at least one system gives that trial a positive decision.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum to identify which samples</span>
<span class="sd">            are relevant for sampling</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial ids to sample from</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_score_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_score_all_systems">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_score_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the scores for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to score.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of scores, one score per system</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_score_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_score_variance_all_systems">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_score_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the score_variances for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation. The score</span>
<span class="sd">        variance is also enabled at the stratum level to allow for metric corrections such as</span>
<span class="sd">        priors for a bayesian confidence interval.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum of which to estimate</span>
<span class="sd">                the score variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of score variances, with one score variance per system</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Metric.estimate_score_variance_upper_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_score_variance_upper_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_variance_upper_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the score_variances for each system on the samples obtained so far with</span>
<span class="sd">        upper bound estimates on the population.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation. The score</span>
<span class="sd">        variance is also enabled at the stratum level to allow for metric corrections such as</span>
<span class="sd">        priors for a bayesian confidence interval.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum of which to estimate the</span>
<span class="sd">            score variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of score variances for upper populations,</span>
<span class="sd">            with one score variance per system ordered by the order of systems in the</span>
<span class="sd">            system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sys_score_var_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_score_variance_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">sys_pop_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">sys_pop_variance_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_variance_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">sys_score_var_upper_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sys_pop_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys_score_var_upper_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">sys_pop_variance_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys_score_var_upper_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Here, we know that have not obtained a single relevant sample but are</span>
                <span class="c1"># not certain that there is a relevant sample</span>
                <span class="c1"># So we assume that the score can be anything (0–1) but that its contribution</span>
                <span class="c1"># is mitigated by the population.</span>
                <span class="c1"># We give the highest variance possible for a proportion, which is 0.25</span>
                <span class="c1"># to balance the unknown and to insist that we get a finite number for estimation</span>
                <span class="n">sys_score_var_upper_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.25</span>
                <span class="c1"># Now give this a finite population correction</span>
                <span class="n">sampled_trials</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">total_trials</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span>
                <span class="n">fpc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">total_trials</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">sampled_trials</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_trials</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">sys_score_var_upper_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_score_var_upper_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">fpc</span>

        <span class="k">return</span> <span class="n">sys_score_var_upper_list</span></div>

<div class="viewcode-block" id="Metric.estimate_pop_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_pop_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the uncertainty (variance) of our estimate of the population size. This is 0</span>
<span class="sd">        when the population is known.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to estimate</span>
<span class="sd">            the population variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population variances, with one population variance per system,</span>
<span class="sd">            ordered by the order of systems int he system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop_var_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">pop_var_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pv</span> <span class="o">*</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pop_var_list</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pop_var_list</span></div>

<div class="viewcode-block" id="Metric.estimate_pop_frac_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_pop_frac_variance_all_systems">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the uncertainty (variance) of our estimate of the population fraction. Returns</span>
<span class="sd">        0 when the population is known.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to estimate</span>
<span class="sd">                the population fraction variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population fraction variances, with one estimate</span>
<span class="sd">            per system,</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="Metric.estimate_population_intervals_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_population_intervals_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_population_intervals_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the confidence intervals for all systems&#39; populations,</span>
<span class="sd">        represented as a three-element list</span>
<span class="sd">        [lower, upper, delta] for each system on a given stratum</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object</span>
<span class="sd">            alpha (float): the level to return the 1 - alpha population confidence for</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of list of float: A list of lists, where there is one list per system, and each</span>
<span class="sd">            system is a</span>
<span class="sd">            three-element list [lower, upper, delta], where delta is the higher of</span>
<span class="sd">            (population_est - lower) and (higher - population)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">system_pop_conf_values</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="n">system_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">system_pop_frac_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system_pop_frac_vars</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="n">system_pops</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop</span><span class="p">):</span>
                <span class="n">system_pop_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">delta</span>
            <span class="n">system_pop_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">delta</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">system_pop_conf_values</span></div>

<div class="viewcode-block" id="Metric.estimate_population_intervals_all_systems_strata"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.estimate_population_intervals_all_systems_strata">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_population_intervals_all_systems_strata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the confidence intervals for all systems&#39; populations,</span>
<span class="sd">        represented as a three-element list</span>
<span class="sd">        [lower, upper, delta] for each system</span>

<span class="sd">        Args:</span>
<span class="sd">            strata (:obj:`aegis.acteval.strata.Strata`): The strata object</span>
<span class="sd">            alpha (float): the level to return the 1 - alpha population confidence for</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of list of float: A list of lists, where there is one list per system, and each</span>
<span class="sd">            system is a</span>
<span class="sd">            three-element list [lower, upper, delta], where delta is the higher of</span>
<span class="sd">            (population_est - lower) and (higher - population)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># system_pop_score_variances = strata.estimate_pop_score_variance_all_systems(self)</span>
        <span class="n">system_pop_conf_values</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">population_frac_variance</span><span class="p">)</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">population</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop</span><span class="p">):</span>
                <span class="n">system_pop_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">strata</span><span class="o">.</span><span class="n">num_trials</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">delta</span>
            <span class="n">system_pop_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">delta</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">system_pop_conf_values</span></div>

<div class="viewcode-block" id="Metric.get_confidence_intervals_true_pop_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.get_confidence_intervals_true_pop_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">get_confidence_intervals_true_pop_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the confidence intervals for all system without uncertainties</span>
<span class="sd">        of population estimates, represented as a three-element list</span>
<span class="sd">        [lower, upper, delta] for each system</span>

<span class="sd">        Args:</span>
<span class="sd">            strata (:obj:`aegis.acteval.strata.Strata`): The strata object</span>
<span class="sd">            alpha (float): the level to return the 1 - alpha confidence for</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of lsit of float: A list of lists, where there is one list per system,</span>
<span class="sd">            and each system is a</span>
<span class="sd">            three-element list [lower, upper, delta], where delta is the higher of</span>
<span class="sd">            (score_est - lower)</span>
<span class="sd">            and (higher - score_est)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># system_scores = strata.estimate_score_all_systems(self)</span>
        <span class="c1"># system_score_variances = strata.estimate_score_variance_all_systems(self)</span>
        <span class="c1"># We have three bounds:</span>
        <span class="c1"># 1) The bound computed from stratified sampling assuming our point estimates of population</span>
        <span class="c1"># are 100% correct and our metric estimate varies</span>
        <span class="c1"># 2) The bound computed from</span>
        <span class="n">system_conf_values</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span><span class="p">)</span>
            <span class="c1"># If we have no upper variance, use the regular score variance</span>
            <span class="k">if</span> <span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">score</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">score</span><span class="p">):</span>
                <span class="n">system_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="c1"># n for t dist: n = system.sampled_trials</span>
            <span class="c1"># t dist: t = scipy.stats.t.ppf(1 - (alpha / 2), n - 1, loc=0, scale=1)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">se</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">score</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">score</span> <span class="o">+</span> <span class="n">delta</span>
            <span class="n">delta_adj</span> <span class="o">=</span> <span class="n">delta</span>
            <span class="n">system_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">delta_adj</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">system_conf_values</span></div>

<div class="viewcode-block" id="Metric.get_confidence_intervals_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.get_confidence_intervals_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">get_confidence_intervals_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strata</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the confidence intervals for all systems, represented as a three-element list</span>
<span class="sd">        [lower, upper, delta] for each system. These confidence intervals include uncertainty</span>
<span class="sd">        for uncertainty in the population estimates.</span>

<span class="sd">        Args:</span>
<span class="sd">            strata (:obj:`aegis.acteval.strata.Strata`): The strata object</span>
<span class="sd">            alpha (float): the level to return the 1 - alpha confidence for</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of list of float: A list of lists, where there is one list per system, and each</span>
<span class="sd">            system is a three-element list [lower, upper, delta], where delta is the</span>
<span class="sd">            higher of (score_est - lower) and (higher - score_est)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># system_scores = strata.estimate_score_all_systems(self)</span>
        <span class="n">system_conf_values</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">strata</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="c1"># Assume two variances are independent</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span> <span class="o">+</span> <span class="n">system</span><span class="o">.</span><span class="n">population_frac_variance</span><span class="p">)</span>
            <span class="c1"># se = np.sqrt(system.score_variance_upper + system.population_frac_variance +</span>
            <span class="c1">#                              np.sqrt(system.score_variance_upper) *</span>
            <span class="c1">#                              np.sqrt(system.population_frac_variance))</span>
            <span class="c1"># If we have only one strata, we do not consider the population variance</span>
            <span class="c1"># since the population variance concerns the uncertainty in the weighting</span>
            <span class="k">if</span> <span class="n">strata</span><span class="o">.</span><span class="n">num_strata</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span><span class="p">)</span>
                <span class="c1"># If we have no upper variance, use the regular score variance</span>
                <span class="k">if</span> <span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance</span><span class="p">)</span>
            <span class="c1"># If we have no upper variance, use the regular score variance</span>
            <span class="k">elif</span> <span class="n">system</span><span class="o">.</span><span class="n">score_variance_upper</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">score_variance</span> <span class="o">+</span> <span class="n">system</span><span class="o">.</span><span class="n">population_frac_variance</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">score</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">score</span><span class="p">):</span>
                <span class="n">system_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="c1"># n for t dist: n = system.sampled_trials</span>
            <span class="c1"># t dist: t = scipy.stats.t.ppf(1 - (alpha / 2), n-1, loc=0, scale=1)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">se</span>
            <span class="c1"># In theory, score_lower &lt;= score and score_upper &gt;= score, but add this</span>
            <span class="c1"># check to guarantee that we do not make the interval smaller</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">score</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">score</span> <span class="o">+</span> <span class="n">delta</span>
            <span class="n">delta_adj</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">score</span> <span class="o">-</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">score</span><span class="p">)</span>
            <span class="n">system</span><span class="o">.</span><span class="n">confidence_value</span> <span class="o">=</span> <span class="n">delta_adj</span>
            <span class="n">system_conf_values</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">delta_adj</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">system_conf_values</span></div>

<div class="viewcode-block" id="Metric.get_actual_score"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.Metric.get_actual_score">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_actual_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">key_df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using a full system data frame and a key data frame, compute the score. This method is</span>
<span class="sd">        used when by the OracleScript that has a full key df.</span>

<span class="sd">        Args:</span>
<span class="sd">            system_df (:obj:`pandas.core.frame.DataFrame`): The data frame of a single system.</span>
<span class="sd">                For metrics that have thresholds,</span>
<span class="sd">                it is assumed that this system has &#39;score&#39; or &#39;decision&#39; columns as needed.</span>
<span class="sd">            key_df (:obj:`pandas.core.frame.DataFrame`): The answer key data frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: A score for that system according to that key.</span>

<span class="sd">        &quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="BinaryPrecisionMetric"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric">[docs]</a><span class="k">class</span> <span class="nc">BinaryPrecisionMetric</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiation of a Metric corresponding to the simplest metric &quot;precision&quot;, or true prositives</span>
<span class="sd">    over total true positives and false positives.</span>
<span class="sd">    Only for binary classification but it handles thresholds and arbitrary key values.</span>

<span class="sd">    This metric approximates accuracy as a combination of two proportions. The first proportion</span>
<span class="sd">    is the proportion of scores that the system classifies as true. The second proportion is</span>
<span class="sd">    of scores that the system classifies as false. We use the system scores rather than the ground</span>
<span class="sd">    truth to split the proportions because we know all of teh system scores.</span>

<span class="sd">    With a threshold, it considers all of the values greater than the threshold to be in the</span>
<span class="sd">    high_key_value class with the remainder of examples to be in the low_key_value_class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">low_key_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_key_value</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score_prior_samples_correction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            key_values (list, optional): The two key values to use, specified as [low, high].</span>
<span class="sd">                None by default, which is replaced with [0, 1].</span>
<span class="sd">            score_prior_samples_correction (float, optional): the adjustment on the score to</span>
<span class="sd">                correct the point estimate</span>
<span class="sd">                for proportions near 0 or 1. In computations, this number is divided by the</span>
<span class="sd">                square root of the number of samples. Defaults to 0.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">=</span> <span class="n">score_prior_samples_correction</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BinaryPrecisionMetric.get_metric_name"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.get_metric_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_metric_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the metric as a string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the metric name</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;BinaryPrecisionMetric&quot;</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.convert_thresholds_to_decisions"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.convert_thresholds_to_decisions">[docs]</a>    <span class="k">def</span> <span class="nf">convert_thresholds_to_decisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When computing Precision, we need to use the threshold specified to convert. This</span>
<span class="sd">        assumes a binary classification problem. This converts to the high key value if the score</span>
<span class="sd">        is strictly higher than the threshold.</span>

<span class="sd">        The decision is added to the System data frame in the column &quot;decision&quot;. The score</span>
<span class="sd">        column is preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            system (:obj:`aegis.acteval.system.System`): the system containing the scores</span>

<span class="sd">        Returns:</span>
<span class="sd">            aegis.acteval.system.System: The modified System object with a modified system_df with</span>
<span class="sd">            decisions in the &quot;decision&quot; column as well as preserving the score values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Important that we copy by reference</span>
        <span class="n">sys_id</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_id</span>
        <span class="n">sys_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_df</span>
        <span class="c1"># For now, use the first threshold value regardless of name</span>
        <span class="n">threshold_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">threshold_df</span>
        <span class="n">sys_threshold_val</span> <span class="o">=</span> <span class="n">threshold_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">threshold_df</span><span class="p">[</span><span class="s2">&quot;system_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sys_id</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sys_threshold_val</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">False</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span><span class="p">,</span>
                                                     <span class="kc">True</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">system</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.find_needed_initial_samples"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.find_needed_initial_samples">[docs]</a>    <span class="k">def</span> <span class="nf">find_needed_initial_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">initial_samples_per_bin</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In order to cover the case where we don&#39;t sample from each stratum necessary edge cases</span>
<span class="sd">        (Such as when the metric is a combination of two components) and to ensure samples</span>
<span class="sd">        from each stratum, this method will find such examples and will sample uniformly at random</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object to find</span>
<span class="sd">                needed samples</span>
<span class="sd">            initial_samples_per_bin (int): The number of initial samples per bin</span>
<span class="sd">            rng (:obj:`numpy.random.RandomState`): random state object with stored random state</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial_id values to sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No samples needed from an empty stratum</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">combined_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_df</span><span class="p">()</span>

        <span class="c1"># Perform this for each system and split samples so that so many are relevant</span>
        <span class="c1"># for each system</span>
        <span class="n">samples_per_system</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">initial_samples_per_bin</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)))</span>
        <span class="n">sys_remaining_samples</span> <span class="o">=</span> <span class="n">initial_samples_per_bin</span>
        <span class="n">samples_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="n">sys_decisions</span> <span class="o">=</span> <span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>
            <span class="n">sys_non_score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">sys_decisions</span><span class="p">),</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">sys_non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">samples_per_system</span><span class="p">:</span>
                <span class="n">curr_samples</span> <span class="o">=</span> <span class="n">sys_non_score_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">sys_non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_samples</span> <span class="o">=</span> <span class="n">sys_non_score_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">samples_per_system</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="n">samples_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">curr_samples</span><span class="p">[</span><span class="s2">&quot;trial_id&quot;</span><span class="p">])</span>
            <span class="n">sys_remaining_samples</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_samples</span><span class="p">)</span>

        <span class="c1"># Sample the rest from what is left out of the total population</span>
        <span class="n">valid_decisions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">combined_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="n">valid_decisions</span> <span class="o">=</span> <span class="p">(</span><span class="n">valid_decisions</span> <span class="o">|</span> <span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span>
                                                  <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">))</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">valid_decisions</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">non_score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">valid_decisions</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">num_needed_samples</span> <span class="o">=</span> <span class="n">sys_remaining_samples</span>
        <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">num_needed_samples</span> <span class="o">-</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remaining_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">samples_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">remaining_samples</span><span class="p">:</span>
            <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_sample</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">remaining_samples</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">samples_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_sample</span><span class="p">[</span><span class="s2">&quot;trial_id&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">samples_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.estimate_samples_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.estimate_samples_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_samples_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system. For Binary</span>
<span class="sd">        Classification Precision, only trials where the system decides on the high key value count.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to determine how</span>
<span class="sd">                many samples count towards the population</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of samples counted for the systems, in the order of the</span>
<span class="sd">            systems in the stratum object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">sys_sample_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_dec&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">sys_sample_list</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.estimate_pop_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.estimate_pop_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system. For Binary</span>
<span class="sd">        Precision, the population is known and is the number of trials where each system has</span>
<span class="sd">        a decision of the high key value.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to determine the</span>
<span class="sd">                population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of population sizes, with the ith element being the population</span>
<span class="sd">            size for system i.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_df</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">sys_pop_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span> <span class="o">+</span> <span class="s1">&#39;_dec&#39;</span><span class="p">]</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_pop_list</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.estimate_pop_frac_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.estimate_pop_frac_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the uncertainty (variance) of our estimate of the population fraction. Returns</span>
<span class="sd">        0 when the population is known. The population is known for Precision so 0 is returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to estimate</span>
<span class="sd">                the population fraction variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population fraction variances, with one estimate</span>
<span class="sd">            per system,</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sys_pop_var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">sys_pop_var_list</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.estimate_score_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.estimate_score_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the score_variances for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation. The score</span>
<span class="sd">        variance is also enabled at the stratum level to allow for metric corrections such as</span>
<span class="sd">        priors for a bayesian confidence interval.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum of which to estimate</span>
<span class="sd">                the score variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of score variances, with one score variance per system</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, return nan</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="c1"># If no trials in key, return nan</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>

        <span class="n">var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
                <span class="n">tp_df</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tp_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tp_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span>
                <span class="n">fp</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">tp</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
                <span class="n">var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">pow</span><span class="p">((</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="n">beta</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">var_list</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.estimate_score_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.estimate_score_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the scores for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to score.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of scores, one score per system</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, return nan</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="c1"># If no trials in key, return nan</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>
        <span class="c1"># score_sample_adj = self.prior_samples_correction</span>
        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">pop_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="k">if</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tp_df</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tp_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tp_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span>
                <span class="n">num_samples</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">sys_pop</span> <span class="o">=</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">fpc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">sys_pop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sys_pop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span><span class="o">*</span><span class="n">fpc</span><span class="p">)</span> <span class="o">/</span> \
                    <span class="p">(</span><span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">*</span> <span class="n">fpc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score_list</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.get_actual_score"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.get_actual_score">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">key_df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using a full system data frame and a key data frame, compute the score. This method is</span>
<span class="sd">        used when by the OracleScript that has a full key df. This computes the system precision</span>
<span class="sd">        on the system. This assumes that the</span>
<span class="sd">        :func:`aegis.acteval.metrics.Metric.convert_thresholds_to_decision()` method has been</span>
<span class="sd">        called to produce the system_df</span>

<span class="sd">        Args:</span>
<span class="sd">            system_df (:obj:`pandas.core.frame.DataFrame`): The data frame of a single system.</span>
<span class="sd">                For metrics that have thresholds,</span>
<span class="sd">                it is assumed that this system has &#39;score&#39; or &#39;decision&#39; columns as needed.</span>
<span class="sd">            key_df (:obj:`pandas.core.frame.DataFrame`): The answer key data frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: A score for that system according to that key.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">key_df</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;trial_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">system_precision</span> <span class="o">=</span> <span class="n">skm</span><span class="o">.</span><span class="n">precision_score</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">],</span> <span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">],</span>
                                               <span class="n">pos_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">system_precision</span></div>

<div class="viewcode-block" id="BinaryPrecisionMetric.get_trials_to_sample_from"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryPrecisionMetric.get_trials_to_sample_from">[docs]</a>    <span class="k">def</span> <span class="nf">get_trials_to_sample_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a stratum, determine the subset of trials that the stratum should draw from.</span>
<span class="sd">        If all samples are relevant, return all of the trial ids. For Precision,</span>
<span class="sd">        this is all trials where some system has a decision of the high key value.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum to identify which samples</span>
<span class="sd">            are relevant for sampling</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial ids to sample from</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_df</span><span class="p">()</span>

        <span class="n">valid_decisions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">score_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="n">valid_decisions</span> <span class="o">=</span> <span class="n">valid_decisions</span> <span class="o">|</span> \
                <span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>

        <span class="n">unsampled_trials</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span>
                                        <span class="o">&amp;</span> <span class="n">valid_decisions</span><span class="p">,</span> <span class="s2">&quot;trial_id&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">unsampled_trials</span></div></div>


<div class="viewcode-block" id="BinaryRecallMetric"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric">[docs]</a><span class="k">class</span> <span class="nc">BinaryRecallMetric</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiation of a Metric corresponding to the simplest metric &quot;Recall&quot;, or true prositives</span>
<span class="sd">    over total true positives and false positives.</span>
<span class="sd">    Only for binary classification but it handles thresholds and arbitrary key values.</span>

<span class="sd">    This metric approximates accuracy as a combination of two proportions. The first proportion</span>
<span class="sd">    is the proportion of scores that the system classifies as true. The second proportion is</span>
<span class="sd">    of scores that the system classifies as false. We use the system scores rather than the ground</span>
<span class="sd">    truth to split the proportions because we know all of teh system scores.</span>

<span class="sd">    With a threshold, it considers all of the values greater than the threshold to be in the</span>
<span class="sd">    high_key_value class with the remainder of examples to be in the low_key_value_class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">low_key_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_key_value</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score_prior_samples_correction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">pop_samples_correction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            key_values (list, optional): The two key values to use, specified as [low, high].</span>
<span class="sd">                None by default, which is replaced with [0, 1].</span>
<span class="sd">            score_samples_correction (float, optional): the adjustment on the score to correct the</span>
<span class="sd">                point estimate</span>
<span class="sd">                for proportions near 0 or 1. In computations, this number is divided by the</span>
<span class="sd">                square root of the number of samples. Defaults to 0.5.</span>
<span class="sd">            pop_samples_correction (float, optional): The adjustment to the population prior for</span>
<span class="sd">                estimating</span>
<span class="sd">                upper population estimates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">=</span> <span class="n">score_prior_samples_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop_samples_correction</span> <span class="o">=</span> <span class="n">pop_samples_correction</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BinaryRecallMetric.get_metric_name"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.get_metric_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_metric_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the metric as a string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the metric name</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;BinaryRecallMetric&quot;</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.convert_thresholds_to_decisions"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.convert_thresholds_to_decisions">[docs]</a>    <span class="k">def</span> <span class="nf">convert_thresholds_to_decisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When computing Recall, we need to use the threshold specified to convert. This</span>
<span class="sd">        assumes a binary classification problem. This converts to the high key value if the score</span>
<span class="sd">        is strictly higher than the threshold.</span>

<span class="sd">        The decision is added to the System data frame in the column &quot;decision&quot;. The score</span>
<span class="sd">        column is preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            system (:obj:`aegis.acteval.system.System`): the system containing the scores</span>

<span class="sd">        Returns:</span>
<span class="sd">            aegis.acteval.system.System: The modified System object with a modified system_df with</span>
<span class="sd">            decisions in the &quot;decision&quot; column as well as preserving the score values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Important that we copy by reference</span>
        <span class="n">sys_id</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_id</span>
        <span class="n">sys_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_df</span>
        <span class="c1"># For now, use the first threshold value regardless of name</span>
        <span class="n">threshold_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">threshold_df</span>
        <span class="n">sys_threshold_val</span> <span class="o">=</span> <span class="n">threshold_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">threshold_df</span><span class="p">[</span><span class="s2">&quot;system_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sys_id</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sys_threshold_val</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">False</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span><span class="p">,</span>
                                                     <span class="kc">True</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">system</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.find_needed_initial_samples"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.find_needed_initial_samples">[docs]</a>    <span class="k">def</span> <span class="nf">find_needed_initial_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">initial_samples_per_bin</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In order to cover the case where we don&#39;t sample from each stratum necessary edge cases</span>
<span class="sd">        (Such as when the metric is a combination of two components) and to ensure samples</span>
<span class="sd">        from each stratum, this method will find such examples and will sample uniformly at random</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object to find</span>
<span class="sd">                needed samples</span>
<span class="sd">            initial_samples_per_bin (int): The number of initial samples per bin</span>
<span class="sd">            rng (:obj:`numpy.random.RandomState`): random state object with stored random state</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial_id values to sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No samples needed from an empty stratum</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">combined_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_df</span><span class="p">()</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span> <span class="p">:]</span>
        <span class="n">non_score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span> <span class="p">:]</span>
        <span class="n">num_needed_samples</span> <span class="o">=</span> <span class="n">initial_samples_per_bin</span>
        <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">num_needed_samples</span> <span class="o">-</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remaining_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">remaining_samples</span><span class="p">:</span>
            <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_sample</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">remaining_samples</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_sample</span><span class="p">[</span><span class="s2">&quot;trial_id&quot;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.estimate_samples_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.estimate_samples_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_samples_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system. For Recall,</span>
<span class="sd">        only trials with the key high key value will count, so this returns the number of</span>
<span class="sd">        sampled trials whose key is the high key value.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to determine how</span>
<span class="sd">                many samples count towards the population</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of samples counted for the systems, in the order of the</span>
<span class="sd">            systems in the stratum object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">score_df</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span>
        <span class="n">sys_sample_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_sample_list</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.estimate_pop_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.estimate_pop_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system. For Recall</span>
<span class="sd">        We are unable to calculate this so we can estimate it by looking at the proportion of</span>
<span class="sd">        keys that are high_key_value to the overall samples and extrapolate this to the population.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>


<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to determine the</span>
<span class="sd">                population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population size estimates, with the ith element being the</span>
<span class="sd">            population estimate for system i. Values are floats because these values are estimates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="n">score_key_pop</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_key_valid_samp</span> <span class="o">=</span> <span class="n">score_df</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pop_prop</span> <span class="o">=</span> <span class="n">score_key_valid_samp</span><span class="o">/</span><span class="n">score_key_pop</span>

        <span class="n">stratum</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span>

        <span class="n">sys_pop_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">population_size</span><span class="o">*</span><span class="n">pop_prop</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_pop_list</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.estimate_pop_frac_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.estimate_pop_frac_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the uncertainty (variance) of our estimate of the population fraction. Returns</span>
<span class="sd">        0 when the population is known. For Recall, the true population is not known so this</span>
<span class="sd">        is almost always nonzero.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to estimate</span>
<span class="sd">                the population fraction variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population fraction variances, with one estimate</span>
<span class="sd">            per system,</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we have only one stratum, we set this to 0; this keeps the random sampler unchanged</span>

        <span class="n">sys_samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="c1"># We need the total number of relevant and non-relevant sampled trials</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="n">sys_pop_var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="c1"># Even if the population is not zero, we have a variance</span>
            <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We need a trial, even if not relevant to estimate the variance</span>
                <span class="n">sys_pop_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys_trials</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sys_samples</span> <span class="o">=</span> <span class="n">sys_samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="c1"># Correction to have a prior</span>
                <span class="n">alpha_v</span> <span class="o">=</span> <span class="n">sys_trials</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_samples_correction</span>
                <span class="n">beta_v</span> <span class="o">=</span> <span class="n">sys_samples</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_samples_correction</span>
                <span class="c1"># Use Beta distribution variance</span>
                <span class="n">sys_pop_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha_v</span> <span class="o">*</span> <span class="n">beta_v</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">pow</span><span class="p">((</span><span class="n">alpha_v</span> <span class="o">+</span> <span class="n">beta_v</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                                                              <span class="p">(</span><span class="n">alpha_v</span> <span class="o">+</span> <span class="n">beta_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">sys_pop_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_pop_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_pop_var_list</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.get_trials_to_sample_from"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.get_trials_to_sample_from">[docs]</a>    <span class="k">def</span> <span class="nf">get_trials_to_sample_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a stratum, determine the subset of trials that the stratum should draw from.</span>
<span class="sd">        If all samples are relevant, return all of the trial ids. For recall, this is any</span>
<span class="sd">        unsampled trial; even though we do not know which ones are relevant, we have no way</span>
<span class="sd">        of rejecting a specific trial before sampling.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum to identify which samples</span>
<span class="sd">            are relevant for sampling</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial ids to sample from</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unsampled_trials</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">stratum_key_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">stratum_key_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span>
                                                      <span class="s2">&quot;trial_id&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">unsampled_trials</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.estimate_score_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.estimate_score_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the scores for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to score.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of scores, one score per system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, return nan</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="c1"># If no trials in key, return nan</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>
        <span class="c1"># score_sample_adj = self.prior_samples_correction</span>
        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">pop_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="k">if</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tp_df</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tp_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tp_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span>
                <span class="n">num_samples</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">sys_pop</span> <span class="o">=</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">fpc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">sys_pop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sys_pop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">*</span> <span class="n">fpc</span><span class="p">)</span> <span class="o">/</span> \
                    <span class="p">(</span><span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">*</span> <span class="n">fpc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score_list</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.estimate_score_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.estimate_score_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the score_variances for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation. The score</span>
<span class="sd">        variance is also enabled at the stratum level to allow for metric corrections such as</span>
<span class="sd">        priors for a bayesian confidence interval.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum of which to estimate</span>
<span class="sd">                the score variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of score variances, with one score variance per system</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, return nan</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="c1"># If no trials in key, return nan</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>

        <span class="n">var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
                <span class="n">tp_df</span> <span class="o">=</span> <span class="n">score_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tp_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tp_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">])</span>
                <span class="n">fp</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">tp</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
                <span class="n">var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">pow</span><span class="p">((</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="n">beta</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">var_list</span></div>

<div class="viewcode-block" id="BinaryRecallMetric.get_actual_score"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryRecallMetric.get_actual_score">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">key_df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using a full system data frame and a key data frame, compute the score. This method is</span>
<span class="sd">        used when by the OracleScript that has a full key df. This computes the system Recall</span>
<span class="sd">        on the system. This assumes that the</span>
<span class="sd">        :func:`aegis.acteval.metrics.Metric.convert_thresholds_to_decision()` method has been</span>
<span class="sd">        called to produce the system_df</span>

<span class="sd">        Args:</span>
<span class="sd">            system_df (:obj:`pandas.core.frame.DataFrame`): The data frame of a single system.</span>
<span class="sd">                For metrics that have thresholds,</span>
<span class="sd">                it is assumed that this system has &#39;score&#39; or &#39;decision&#39; columns as needed.</span>
<span class="sd">            key_df (:obj:`pandas.core.frame.DataFrame`): The answer key data frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: A score for that system according to that key.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">key_df</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;trial_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">system_recall</span> <span class="o">=</span> <span class="n">skm</span><span class="o">.</span><span class="n">recall_score</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">],</span> <span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">],</span>
                                         <span class="n">pos_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">system_recall</span></div></div>


<div class="viewcode-block" id="BinaryAccuracyMetric"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric">[docs]</a><span class="k">class</span> <span class="nc">BinaryAccuracyMetric</span><span class="p">(</span><span class="n">Metric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiation of a Metric corresponding to the simplest metric &quot;accuracy&quot;, or percentage</span>
<span class="sd">    correct. Only for binary classification but it handles thresholds and arbitrary key values.</span>

<span class="sd">    With a threshold, it considers all of the values greater than the threshold to be in the</span>
<span class="sd">    high_key_value class with the remainder of examples to be in the low_key_value_class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_key_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high_key_value</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score_samples_correction</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">score_variance_samples_correction</span><span class="o">=</span><span class="mi">9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        Args:</span>
<span class="sd">            key_values (list, optional): The two key values to use, specified as [low, high].</span>
<span class="sd">                None by default, which is replaced with [0, 1].</span>
<span class="sd">            score_samples_correction (float, optional): the adjustment on the score to correct the</span>
<span class="sd">                point estimate</span>
<span class="sd">                for proportions near 0 or 1. In computations, this number is divided by the</span>
<span class="sd">                square root of the number of samples. Defaults to 1.</span>
<span class="sd">            score_variance_samples_correction (float, optional): the adjustment on the score to</span>
<span class="sd">                correct</span>
<span class="sd">                the score variance estimate.</span>
<span class="sd">                for proportions near 0 or 1. In computations, this number is divided by the</span>
<span class="sd">                square root of the number of samples. This correction is</span>
<span class="sd">                added to the score_samples_correction to give additional width to the score</span>
<span class="sd">                variance. Defaults to 9.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span> <span class="o">=</span> <span class="n">key_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_samples_correction</span> <span class="o">=</span> <span class="n">score_samples_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_variance_samples_correction</span> <span class="o">=</span> <span class="n">score_variance_samples_correction</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="BinaryAccuracyMetric.get_metric_name"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.get_metric_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_metric_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the metric as a string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the metric name</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;BinaryAccuracy&quot;</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.find_needed_initial_samples"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.find_needed_initial_samples">[docs]</a>    <span class="k">def</span> <span class="nf">find_needed_initial_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">,</span> <span class="n">initial_samples_per_bin</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In order to cover the case where we don&#39;t sample from each stratum necessary edge cases</span>
<span class="sd">        (Such as when the metric is a combination of two components) and to ensure samples</span>
<span class="sd">        from each stratum, this method will find such examples and will sample uniformly at random</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum object to find</span>
<span class="sd">                needed samples</span>
<span class="sd">            initial_samples_per_bin (int): The number of initial samples per bin</span>
<span class="sd">            rng (:obj:`numpy.random.RandomState`): random state object with stored random state</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial_id values to sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No samples needed from an empty stratum</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">combined_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_df</span><span class="p">()</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span> <span class="p">:]</span>
        <span class="n">non_score_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span> <span class="p">:]</span>
        <span class="n">num_needed_samples</span> <span class="o">=</span> <span class="n">initial_samples_per_bin</span>
        <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">num_needed_samples</span> <span class="o">-</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remaining_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">remaining_samples</span><span class="p">:</span>
            <span class="n">remaining_samples</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_sample</span> <span class="o">=</span> <span class="n">non_score_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">remaining_samples</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_sample</span><span class="p">[</span><span class="s2">&quot;trial_id&quot;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.convert_thresholds_to_decisions"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.convert_thresholds_to_decisions">[docs]</a>    <span class="k">def</span> <span class="nf">convert_thresholds_to_decisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When computing Accuracy, we need to use the threshold specified to convert. This Accuracy</span>
<span class="sd">        assumes a binary classification problem. This converts to the high key value if the score</span>
<span class="sd">        is strictly higher than the threshold.</span>

<span class="sd">        The decision is added to the System data frame in the column &quot;decision&quot;. The score</span>
<span class="sd">        column is preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            system (:obj:`aegis.acteval.system.System`): the system containing the scores</span>

<span class="sd">        Returns:</span>
<span class="sd">            aegis.acteval.system.System: The modified System object with a modified system_df with</span>
<span class="sd">            decisions in the &quot;decision&quot; column as well as preserving the score values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Important that we copy by reference</span>
        <span class="n">sys_id</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_id</span>
        <span class="n">sys_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">system_df</span>
        <span class="c1"># For now, use the first threshold value regardless of name</span>
        <span class="n">threshold_df</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">threshold_df</span>
        <span class="n">sys_threshold_val</span> <span class="o">=</span> <span class="n">threshold_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">threshold_df</span><span class="p">[</span><span class="s2">&quot;system_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sys_id</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sys_threshold_val</span>
        <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="kc">False</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_key_value</span><span class="p">,</span>
                                                     <span class="kc">True</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_key_value</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">system</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.estimate_samples_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.estimate_samples_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_samples_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of sampled trials relevant to the metric for each system. For Binary</span>
<span class="sd">        Classification Accuracy, each trial sampled counts, so this returns the number of sampled</span>
<span class="sd">        trials in the stratum.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to determine how</span>
<span class="sd">                many samples count towards the population</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of samples counted for the systems, in the order of the</span>
<span class="sd">            systems in the stratum object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="n">sys_sample_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_sample_list</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.estimate_pop_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.estimate_pop_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the total number of trials to be considered for the metric computation. For</span>
<span class="sd">        Binary classification of accuracy, it is simply the total number of trials in that stratum.</span>


<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to determine the</span>
<span class="sd">                population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of population sizes, with the ith element being the population</span>
<span class="sd">            size for system i.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stratum</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span>
        <span class="n">sys_pop_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">stratum</span><span class="o">.</span><span class="n">population_size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">sys_pop_list</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.estimate_pop_frac_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.estimate_pop_frac_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_pop_frac_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the uncertainty (variance) of our estimate of the population fraction. Returns</span>
<span class="sd">        0 when the population is known. For Accuracy, the population is known so this method</span>
<span class="sd">        Returns 0.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum of which to estimate</span>
<span class="sd">                the population fraction variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of population fraction variances, with one estimate</span>
<span class="sd">            per system,</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sys_pop_var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">sys_pop_var_list</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.get_trials_to_sample_from"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.get_trials_to_sample_from">[docs]</a>    <span class="k">def</span> <span class="nf">get_trials_to_sample_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a stratum, determine the subset of trials that the stratum should draw from.</span>
<span class="sd">        If all samples are relevant, return all of the trial ids. For accuracy, all trials are</span>
<span class="sd">        relevant so all trials are returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): the stratum to identify which samples</span>
<span class="sd">            are relevant for sampling</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of object: A list of trial ids to sample from</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unsampled_trials</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">stratum_key_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">stratum_key_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]),</span>
                                                      <span class="s2">&quot;trial_id&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">unsampled_trials</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.estimate_score_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.estimate_score_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the scores for each system on the samples obtained so far. The score here</span>
<span class="sd">        uses the accuracy_score() method from sklearn to compute the score as if it were</span>
<span class="sd">        a binomial value and we are computing the proportion of matches.</span>
<span class="sd">        Neither Stratum nor System objects are updated during this computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum to score.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of scores, one score per system</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, return nan</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>

        <span class="n">score_df</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">get_combined_systems_score_df</span><span class="p">()</span>
        <span class="c1"># If no trials in key, return nan</span>
        <span class="k">if</span> <span class="n">score_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>
        <span class="n">score_sample_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">pop_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">sys_id</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">system_id</span>
            <span class="n">acc_p</span> <span class="o">=</span> <span class="n">skm</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span>
                <span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">],</span> <span class="n">score_df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_dec&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">sys_pop</span> <span class="o">=</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fpc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">sys_pop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">sys_pop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">score_sample_adj</span> <span class="o">=</span> <span class="n">fpc</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_samples_correction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">))</span>
            <span class="n">corr_acc_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc_p</span> <span class="o">*</span> <span class="n">num_samples</span> <span class="o">+</span> <span class="n">score_sample_adj</span><span class="p">)</span> \
                <span class="o">/</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">score_sample_adj</span><span class="p">)</span>
            <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_acc_p</span>
        <span class="k">return</span> <span class="n">score_list</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.estimate_score_variance_all_systems"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.estimate_score_variance_all_systems">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_score_variance_all_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stratum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the score_variances for each system on the samples obtained so far.</span>
<span class="sd">        Neither Stratum nor System objects are not updated during this computation. The score</span>
<span class="sd">        variance is also enabled at the stratum level to allow for metric corrections such as</span>
<span class="sd">        priors for a bayesian confidence interval.</span>

<span class="sd">        Args:</span>
<span class="sd">            stratum (:obj:`aegis.acteval.stratum.Stratum`): The stratum of which to estimate</span>
<span class="sd">                the score variance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of float: A list of score variances, with one score variance per system</span>
<span class="sd">            ordered by the order of systems in the system id list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no trials in stratum, 0</span>
        <span class="n">samples_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_samples_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">pop_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_pop_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">]</span>
        <span class="n">score_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_score_all_systems</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="n">score_var_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">))]</span>
        <span class="n">score_var_sample_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_samples_correction</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">system_list</span><span class="p">)):</span>
            <span class="n">acc_p</span> <span class="o">=</span> <span class="n">score_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">acc_p</span><span class="p">):</span>
                <span class="n">score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="n">samples_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">sys_pop</span> <span class="o">=</span> <span class="n">pop_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fpc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">sys_pop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sys_pop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">score_sample_adj</span> <span class="o">=</span> <span class="n">fpc</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_samples_correction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">))</span>
                <span class="n">score_var_sample_adj</span> <span class="o">=</span> <span class="n">fpc</span> <span class="o">*</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_variance_samples_correction</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">))</span>
            <span class="n">corr_acc_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc_p</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">score_sample_adj</span><span class="p">)</span> <span class="o">+</span> <span class="n">score_var_sample_adj</span><span class="p">)</span> \
                <span class="o">/</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">score_sample_adj</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">score_var_sample_adj</span><span class="p">)</span>
            <span class="c1"># Use binomial variance without a finite correction error.</span>
            <span class="c1"># In this case, the &quot;n&quot; is divided out by the number of trials</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_acc_p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr_acc_p</span><span class="p">)</span>
                <span class="n">score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">/</span>\
                    <span class="p">(</span><span class="n">num_samples</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">score_sample_adj</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">score_var_sample_adj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="n">score_var_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">score_var_list</span></div>

<div class="viewcode-block" id="BinaryAccuracyMetric.get_actual_score"><a class="viewcode-back" href="../../../api/aegis.acteval.metrics.html#aegis.acteval.metrics.BinaryAccuracyMetric.get_actual_score">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">key_df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using a full system data frame and a key data frame, compute the score. This method is</span>
<span class="sd">        used when by the OracleScript that has a full key df. This computes the system Accuracy</span>
<span class="sd">        on the system. This assumes that the</span>
<span class="sd">        :meth:`aegis.acteval.metrics.Metric` method has been</span>
<span class="sd">        called to produce the system_df</span>

<span class="sd">        Args:</span>
<span class="sd">            system_df (:obj:`pandas.core.frame.DataFrame`): The data frame of a single system.</span>
<span class="sd">                For metrics that have thresholds,</span>
<span class="sd">                it is assumed that this system has &#39;score&#39; or &#39;decision&#39; columns as needed.</span>
<span class="sd">            key_df (:obj:`pandas.core.frame.DataFrame`): The answer key data frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: A score for that system according to that key.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">key_df</span><span class="p">,</span> <span class="n">system_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;trial_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">system_accuracy</span> <span class="o">=</span> <span class="n">skm</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">],</span> <span class="n">score_df</span><span class="p">[</span><span class="s2">&quot;decision&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">system_accuracy</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, NIST MIG

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>